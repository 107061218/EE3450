# Programming Assignment #3 Pipeline Simulation for Windows (Due Dec. 17, 2020)

In this assignment, we will use a RISC-V pipeline simulator (Ripes) to observe the working of the pipeline.

## 1. Install Ripes

1. Please download the release version of Ripes from [Ripes Release build](https://github.com/mortbopet/Ripes/releases)
    *(`Ripes-v2.1.0-win-x86_64.zip` is the current version for Windows platform.)*
2. Please extract the file. [screen shot-1](https://drive.google.com/file/d/11K_jStorwhMgWdS2b2l59gMGRiw8pReB/view?usp=sharing) [screen shot-2](https://drive.google.com/file/d/15g735y9B8OMbIBQyx-bnrZHpqdTOT0nh/view?usp=sharing)
    *(right click and extract on Windows. Location we test in this example is `D:\ee3450`)*

## 2. Install Toolchain

1. Please download the SiFive RISC-V toolchain from https://github.com/sifive/freedom-tools/releases. 
    *(For example, riscv64-unknown-elf-gcc-8.3.0-2020.04.1-x86_64-w64-mingw32.zip is a version for Windows.)*
3. Please extract the file to a folder.[screen shot-1](https://drive.google.com/file/d/1jQqkwrWZa8tWVkGzvpic2GAU6Aa8lWOR/view?usp=sharing) [screen shot-2](https://drive.google.com/file/d/1f420_RQsfD-PSRMGnYVc3UkhDJxNudCr/view?usp=sharing)
*(right click and select extract on windows. Location we test in this example is `D:\ee3450`)* 
5. Please find out from the extract folder where `riscv64-unknown-elf-gcc` is.(In this example the file location is`D:\ee3450\riscv64-unknown-elf-gcc-8.3.0-2020.04.1-x86_64-w64-mingw32\bin`) 
6. This folder is denoted as `$env:RV64_GCC_PATH` below. You may use following command to setup environment variable: ` $env:RV64_GCC_PATH=D:\ee3450\riscv64-unknown-elf-gcc-8.3.0-2020.04.1-x86_64-w64-mingw32\bin `

## 3. Test Setup
      
1. Download cmul.S from PA3.
2. Start a terminal.[screen shot](https://drive.google.com/file/d/1is2AQXVKsfdZvH0z7XUCtegD7LwK5Hv3/view?usp=sharing) 
    *(for windows please enter "powershell" at folder's address block section and press "enter" )*
4. Go to the download folder with cmul.S. 
    *(For example, ``` cd D:\ee3450\ ```)*
5. Generate an rv32im executable: [screen shot](https://drive.google.com/file/d/1KdCSm8NeTWVRxn1ZBjeqHj1DSwq8mQ-A/view?usp=sharing) 
    *(Before generate the file, please check $RV64GCCPATH is already set with the folder location where riscv64-unknown-elf-gcc is.)*
    ``` 
    & $env:RV64_GCC_PATH\riscv64-unknown-elf-gcc.exe -march=rv32im -mabi=ilp32 -s -static -nostdlib -o cmul_test.elf cmul.S 
    ```

    > * "-march=rv32im" to use an ISA version with 32-bit architecture and integer ("i") and multiply ("m") supports.
    > * "-mabi=ilp32" to specify the language data model. In this setup, integer ("i"), long ("l"), and pointer ("p") are all 32-bit.
    > * "-s" to strip symbols from binary.
    > * "-static" to link statically to produce a complete executable.
    > * "-nostdlib" do no use stdlib.
    > * "-o" specify output name.

5. Start Ripes GUI by double clicking the program. [screen shot-1](https://drive.google.com/file/d/1vDodJSkBFlt79fG-YQcg56Hm9ppISjpI/view?usp=sharing) [screen shot-2](https://drive.google.com/file/d/1357Xc7RZSYmdPDeXRfJSVAA_xZkbgM1n/view?usp=sharing)
6. File --> Load Program [screen shot](https://drive.google.com/file/d/1f3HtNAY2iyPpJ3UK4QSHHDgwUYfEifIN/view?usp=sharing)
   Use "Open" to search for cmul.elf.
   In our example, cmul.elf is in `cd D:\ee3450\`.
7. Click '>>' to run and simulate the binary in Ripes without GUI updates.


## 4. Write an Assembly Code

1. Please follow above cmul.S to write your own assembly codes. The code should at least include dependency of the following types:
   (RAW means read-after-write: we will use a register which is an Rd of earlier instructions).
    
   (1) R-types RAW at following 1st instruction 
   (2) R-types RAW at following 2nd instruction 
   (3) Load RAW at following 1st instruction 
   (4) Load RAW at following 2nd instruction
   (5) branch instruction (control hazard).  
    
   Please comment your codes to indicate above conditions.

   Note that Ripes simulator has a different `gp` register setup as the binary generated by toolchain.
   So Ripes cannot resolve correctly variable address except for the first variable.
   The workaround is to use the first variable address as base to index other variables (as shown in the cmul.S).


2. Please run your program with Ripes to make sure it's correct.

## 5. Simulate Pipeline

1. Please try to familiarize yourself with the Ripes simulator (https://github.com/mortbopet/Ripes/wiki/Ripes-Introduction). 
2. Please run your code cycle by cycle with the 5-stage pipeline (default processor with forwarding and hazard detection enabled). 
   Please capture the cycles (with both pipeline details and stages) when the processor handles above 5 types of dependency or control hazards.
    Write a report to document the step by step process.
3. Redo above with a 5-stage pipeline without forwarding or hazard detection (select from the top-left corner).
   Note that you need to insert `nop` to make sure the program execute correctly (to handle hazards).
   You can write the report of this part in the same document.

   Note that we need to revise the first "la" instruction in the original cmul.S to run on this processor. 
   It's because "la t0, aa" is translated by the assembler into two instructions (you can see it in the right side panel in Ripes):

   ```
   #original version
   la t0, aa
   nop
   nop
   lw a0, 0(t0)
   ```

   ```
   #translated version by assembler
   auipc t0, 0x1
   addi t0, t0, 140
   nop
   nop
   lw a0, 0(t0)
   ```

   Since this is a processor without forwarding and stall detection, the "addi"
   without "nop" cannot get the correct t0 from auipc (actually t0 is still 0
   in register file, so the result is t0=140 or 0x8C). Therefore, we get "0" for all the following loads.

   The solution is to directly use the two instructions above in the assembly,
   but we have to manually insert the correct value for the address of the data
   segment as shown in the following codes:

   ```
   auipc t0, 0x1
   nop
   nop
   addi t0, t0, 148
   nop
   nop
   lw a0, 0(t0)
   ```

   In the codes, we insert 3 additional nops, because the register file does
   not support same cycle write and read. And the addi imm is changed to 156 (from 144), because
   we the 3 nops increase the text (code) segment by 12 bytes. This increase of code segment also 
   move the beginning of data segment 12 bytes further (hence 144+12=156).

   We can use the assembler to calculate this address for us by keeping the "la" instruction and inserting 2 nops:

   ```
   la t0, aa
   nop
   nop
   nop
   nop
   lw a0, 0(t0)
   ```
   After loading the translated binary into Ripes, we can check the addi imm value, which is the lower 12 bits
   of data segment.



## 6. Submit reports

Please submit your assembly codes and report files in pdf to the [following google form](https://forms.gle/qAxaeZJDLDy6mb369).
